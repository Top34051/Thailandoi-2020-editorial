/*
 Author: zoomswk
 Full solution
 Time complexity: O((N+M) log (N+M))
 */

#include "malwarex.h"
#include <algorithm>
using namespace std;

int get_lg(int x){
    x--;
    int lg = 0;
    while(x){
        lg++;
        x >>= 1;
    }
    return lg;
}

void alice(int N, int M, std::vector<int> L){
    int sum = 0;
    for(int x : L) sum += x;
    if(sum != M) printf("alice error: %d+%d != %d\n", N, M, sum);
    
    int lg = get_lg(N);
    
    vector<int> flag(N+M, 0);
    int idx=0;
    for(int i=0; i<N+1; i++){
        for(int j=0; j<L[i]; j++){
            flag[idx++] = 1;
        }
        idx++;
    }
    
    vector<int> num(N+M, 0);
    
    int cur=0;
    
    vector<int> pos(N);
    
    for(int i=0; i<N+M; i++){
        if(!flag[i]){
            pos[cur] = i;
            num[i] = cur++;
        }
    }
    
    vector<string> S(lg);
    
    for(int i=0; i<lg; i++){
        string s = "";
        for(int j=0; j<N+M; j++){
            if(!flag[j]){
                s += (num[j]&1) ? '1' : '0';
                num[j] >>= 1;
            }
        }
        S[i] = sendMessage(s);
    }
    
    vector<int> occ(N, 0);
    vector<int> where(N, 0);
    
    for(int i=0; i<N+M; i++){
        int x = 0;
        for(int j=lg-1; j>=0; j--){
            x <<= 1;
            if(S[j][i] == '1') x++;
        }
        if(x < N){ // important condition x < N, otherwise out of bound
            occ[x]++;
            if(!flag[i]) where[x] = occ[x]-1;
        }
    }
    
    vector<pair<int, int>> vec(N);
    
    for(int i=0; i<N; i++) vec[i] = make_pair(occ[i]-1, i);
    
    sort(vec.begin(), vec.end());
    
    string s = "";
    for(int i=0; i<N; i++) s += '0';
    
    int needer = 0;
    for(int i=0; i<N; i++){
        while(needer < N && !vec[needer].first) needer++;
        if(needer == N) break;
        if(where[vec[needer].second]){
            s[vec[i].second] = '1';
            where[vec[needer].second]--;
        }
        vec[needer].first--;
    }
    
    sendMessage(s);
    
    return;
}

vector<int> bob(int N, int M, int Q, std::vector<std::string> S){
    int lg = get_lg(N);
    
    if(lg+1 != Q) exit(1);
    
    vector<vector<int>> qk(N);
    
    vector<int> occ(N, 0);
    vector<int> where(N, 0);
    
    for(int i=0; i<N+M; i++){
        int x = 0;
        for(int j=lg-1; j>=0; j--){
            x <<= 1;
            if(S[j][i] == '1') x++;
        }
        if(x < N){ // important condition x < N, otherwise out of bound
            occ[x]++;
            qk[x].push_back(i);
        }
    }
    
    vector<pair<int, int>> vec(N);
    
    for(int i=0; i<N; i++) vec[i] = make_pair(occ[i]-1, i);
    
    sort(vec.begin(), vec.end());
    
    vector<int> loc(N);
    vector<int> mrk(N+M, 1);
    
    int needer = 0;
    for(int i=0; i<N; i++){
        int b = vec[i].second;
        // first, conclude the location of b
        loc[b] = qk[b][where[b]];
        mrk[loc[b]] = 0; // mark it as non-overwritten
        // get info for other bits
        while(needer < N && !vec[needer].first) needer++;
        if(needer == N) continue; // NOT BREAK!
        if(S[lg][loc[b]] == '1') where[vec[needer].second]++;
        vec[needer].first--;
    }
    
    vector<int> res(N+1);
    
    int ptr=0;
    int cnt=0;
    for(int i=0; i<N+M; i++){
    	if(mrk[i]) cnt++;
    	else{
    		res[ptr++] = cnt;
    		cnt = 0;
    	}
    }

    res[ptr++] = cnt;
    
    return res;
}